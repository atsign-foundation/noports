import 'dart:async';
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:at_chops/at_chops.dart';
import 'package:at_utils/at_logger.dart';

///
/// Verifies signature of the data received over the socket using the same signing algorithm used to sign the data
/// See [SigningAlgoType] to know more about supported signing algorithms
/// See [HashingAlgoType] to know more about supported hashing algorithms
///
/// Expects the first message received in JSON format, with the following structure:
/// {
///       "signature":"<base64 encoded signature>",
///       "hashingAlgo":"<algo>",
///       "signingAlgo":"<algo>"
///  }
///
/// also expects signature to be base64 encoded
///
///
class SignatureAuthVerifier {
  static final AtSignLogger logger = AtSignLogger(' SignatureAuthVerifier ');

  /// Public key of the signing algorithm used to sign the data
  String publicKey;

  /// data that was signed, this is the data that should be matched once the signature is verified
  String dataToVerify;

  /// string generated by rvd which should be included in auth strings from sshnp and sshnpd
  String rvdNonce;

  /// a tag to help decipher logs
  String tag;

  SignatureAuthVerifier(
    this.publicKey,
    this.dataToVerify,
    this.rvdNonce,
    this.tag,
  );

  AtSigningResult _verifySignature(AtSigningVerificationInput input) {
    AtChopsKeys atChopsKeys = AtChopsKeys();
    AtChops atChops = AtChopsImpl(atChopsKeys);
    return atChops.verify(input);
  }

  /// We expect the authenticating client to send a JSON message with
  /// this structure:
  /// ```json
  /// {
  /// "signature":"&lt;signature&gt;",
  /// "hashingAlgo":"&lt;algo&gt;",
  /// "signingAlgo":"&lt;algo&gt;",
  /// "payload":&lt;the data which was signed&gt;
  /// }
  /// ```
  /// The signature is verified against [dataToVerify] and, although not
  /// strictly necessary, the rvdNonce is also checked in what the client
  /// send in the payload
  Future<(bool, Stream<Uint8List>?)> authenticate(Socket socket) async {
    Completer<(bool, Stream<Uint8List>?)> completer = Completer();
    bool authenticated = false;
    StreamController<Uint8List> sc = StreamController();
    logger.info('SignatureAuthVerifier for $tag: starting listen');
    List<int> buffer = [];
    socket.listen((Uint8List data) {
      if (authenticated) {
        sc.add(data);
      } else {
        buffer.addAll(data);
        if (buffer.contains(10)) {
          logger.finer('original buffer length ${buffer.length}');
          List<int> authBuffer = buffer.sublist(0, buffer.indexOf(10));
          logger.finer('authBuffer length ${authBuffer.length}');
          buffer.removeRange(0, buffer.indexOf(10) + 1);
          logger.finer('remaining buffer length ${buffer.length}');

          try {
            final message = String.fromCharCodes(authBuffer);
            logger.finer('SignatureAuthVerifier $tag received data: $message');
            var envelope = jsonDecode(message);
            logger.finer('SignatureAuthVerifier $tag decoded JSON message OK');

            final hashingAlgo =
                HashingAlgoType.values.byName(envelope['hashingAlgo']);
            final signingAlgo =
                SigningAlgoType.values.byName(envelope['signingAlgo']);

            var payload = envelope['payload'];
            if (payload == null || payload is! Map) {
              completer.completeError(
                  'Received an auth signature which does not include the payload');
              return;
            }
            if (payload['rvdNonce'] != rvdNonce) {
              completer.completeError(
                  'Received rvdNonce which does not match what is expected');
              return;
            }

            AtSigningVerificationInput input = AtSigningVerificationInput(
                dataToVerify, base64Decode(envelope['signature']), publicKey)
              ..signingAlgorithm = DefaultSigningAlgo(null, hashingAlgo)
              ..signingMode = AtSigningMode.data
              ..signingAlgoType = signingAlgo
              ..hashingAlgoType = hashingAlgo;

            AtSigningResult atSigningResult = _verifySignature(input);
            bool result = atSigningResult.result;

            if (result == false) {
              logger.shout('SignatureAuthVerifier $tag :'
                  ' verification FAILURE :'
                  ' ${atSigningResult.result}');
              completer.completeError(
                  'Signature verification failed. Signatures did not match.');
              return;
            }

            logger.info('SignatureAuthVerifier $tag :'
                ' verification SUCCESS :'
                ' ${atSigningResult.result}');
            authenticated = true;
            completer.complete((true, sc.stream));

            if (buffer.isNotEmpty) {
              sc.add(Uint8List.fromList(buffer));
            }
          } catch (e) {
            logger.shout('SignatureAuthVerifier $tag :'
                ' verification FAILED with exception :'
                ' $e');

            completer.completeError('Error during socket authentication: $e');
          }
        }
      }
    }, onError: (error) => sc.addError(error), onDone: () => sc.close());
    return completer.future;
  }
}
